\section{Verification and synthesis}
\label{sec:veri-syn}

This section presents in more details the view interface and their
usage by three examples, namely real-time verification and synthesis
that are fully automatically enabled by database for virtual network,
one big switch, and distributed firewalls.

% three example view abstractions, together with the fully automatic
% verification and synthesis services,

\Subsection{Verification and synthesis as data synchronization}

% \todo{(this subsection) HotNet texts, will rework}

A network is in constant change. A virtual view is useful only if its
records are fresh -- reflecting the latest network instantly. For
example, when per-switch rules change, a query on the high-level
policy view \nd{e2e\_routing} (Table~\ref{tb:endpoint}) shall
automatically returns the updated \nd{e2e} reachability. Conversely,
to enable network manipulation via views, the base tables need to be
updated to reflect operations on the views.  For example, to set a new
route \nd{(1,5,4)} for \nd{flow 1} in the example network
(Figure~\ref{fig:eg-one-big-switch} (left)), a user simply insert a new
record denoting the path into the \nd{routing\_policy} view with
\nd{flow} attribute set to \nd{1}. \Sys is responsible of pushing this
abstract view insert into the relevant base \nd{configuration}
inserts.

Generally, view maintenance that keeps virtual views fresh and view
update that synthesizes the base table changes, jointly form a
bi-directional data synchronizer between the base and the view. While
modern DBSes implement view maintenance very efficiently, view update
is supported for restricted
cases~\cite{ak-view-udpate-thesis,relational-lenses}. This is no
surprise, as view update is the harder one: a view contains only partial
information of the base, it is not always possible to locate a unique
base table update~\cite{Bancilhon:view-update-semantics}. To enable
network operations on views, \Sys takes advantage of existing view
maintenance implementation and extends the support of view updates to
network view updates.

\Paragraph{Real-time view maintenance enables network verification.}
\textit{View maintenance} is well supported in modern database systems
(DBS), which \Sys adopts straightforwardly. Specifically, when a view
generated by SQL query program $q$, is queried by a SQL program $p$,
view maintenance translates $p$ on $q$ into queries $p \circ q$ on the
base tables.
% , hence always returning information that is update to the latest
% network state. On the other hand, since views are virtual, This very
% fast re-computation of $p$ keeps the view fresh.  requiring
% re-computation every time it is referred, an alternative is to
% materialize (actually store) the view to accelerate query on the
% views. In this case, view maintenance incrementally updates the
% materialized view table with regard to base table change.
Interestingly, view maintenance offers exactly what is needed in
real-time network verification: by specifying the property of interests
as $p$ over $q$, view maintenance performs check of $p \circ q$ on
network states on the fly. % As shown in \S~\ref{sec:eval},
% checking reachability on a network with more than 10k nodes costs
% less than 10 ms, magnitudes smaller compared to the typically
% per-rule installation or TE operation delay~\cite{b4,ffc}.

\Paragraph{Real-time view update enables network synthesis.}  
Given the ambiguity and non-existence in view update, we first
characterize the correctness criteria in networking. We identify
updates that keep a view's independent and complementary counter-parts
constant. Two views are \textit{independent} if the update on one does
not affect that on the other. Two views are \textit{complementary}, if
they contain enough information to recover the base tables.
% , \ie there alawys exists some base table updates that correctly
% reflect the updated view while keeping the rest views constant.
% In \Sys, it is desirable for views to be independent so they don't
% conflict each other. 
A view updates that keeps the independent views constant eliminates
accident changes made to other existing views; An update that keep a
view's \textit{complementary} constant is a stronger requirement that
does not pollute any possible views (existing and future ones).

\Sys assumes user views are independent, and only performs updates
that keep independent views constant.  In the current prototype, view
update is implemented by hand coded triggers, the call-back functions
that are automatically fired to update the bases when the associated
view update is issued. We evaluate this manual implementation (details
in \S~\ref{sec:eval}) to measure the DB induced delay.
Ultimately, \Sys aims for a generic view update algorithm that
synthesizes for any user-defined views. (We have sketched a novel
algorithm, omitted due to space.) We leave the implementation of the
generic algorithm for future work.

% \input{preliminary-eval}


% \subsection{Verification example}

% \subsection{Synthesis example}

\subsection{Virtual network abstraction and enterprise outsourcing}

\begin{sql}
select * from vn_reachability where flow_id = 77899 ;
 flow_id | ingress | egress 
---------+---------+--------
   77899 |     486 |     19  
   ...
\end{sql}

This entry corresponds to a record in configuration as follows:
\begin{sql}
SELECT flow_id, pv FROM configuration_pv WHERE flow_id = 77899;
---------+----------------------------------
 flow_id |                pv                
   77899 | {486,498,462,463,456,472,109,19}
\end{sql}

To update the virtual network policy that revoke transient service for
flow \nd{77899} between ingress \nd{486} and egress \nd{19}, the user
could direcly modify the \nd{vn\_reachability} table by deleting the
corresponding record as follows:
\begin{sql}
DELETE FROM vn_reachability WHERE 
        flow_id = 27079 AND ingress = 486 AND egress = 19;  
\end{sql}

This deletion results in the deletion of three switch-level
configurations as follows:
\begin{sql}
[[462, 463], [486, 498], [498, 462]]  
\end{sql}
The reason that only three entries at switches \nd{462, 486, 498} are
removed is that the rest of the ... are 

\begin{sql}
SELECT flow_id, pv FROM configuration_pv WHERE flow_id = 77899;
 flow_id |                pv                
---------+----------------------------------
   77899 | {483,463,456,472,109,19}
   77899 | {486,498,462,463,456,472,109,19}
   ...
\end{sql}

Similarly, on user request for adding new or updating exiting virtual
network end to end policy, \Sys synthesizes the relevant switch-level
configuration modification.
Add new policy:
\begin{sql}
INSERT INTO vn_reachability VALUES (55716, 557, 483);  
\end{sql}

Update policy:
\begin{sql}
UPDATE vn_reachability SET egress = 230
        WHERE flow_id = 97940 AND ingress = 497;  
\end{sql}

Finally, it is worth noting that, a policy update request may not
always be valid. For example, a deletion of policy \nd{(42692, 497,
  375)} in ... 

\begin{sql}
SELECT source, target, pv FROM configuration_pv WHERE flow_id = 42692;
 source | target |                pv                 
--------+--------+-----------------------------------
    486 |    375 | {486,498,462,463,456,472,108,375}
    497 |    230 | {497,462,463,456,230}
    497 |    375 | {497,462,463,456,472,108,375}
    ...
\end{sql}

While \Sys, which utilizes the default view updates mechanism
implemented by postgres, will simply remove policy \nd{(42692, 497,
  375)} from \nd{vn\_reachability} view, and leaves the per-switch
configuration unchanged. 
% \begin{sql}
% Switch delta after del of 42692 between 497 and 375 []
% \end{sql}

\subsection{One big switch abstraction and distributed firewall}

\begin{sql}
ALTER VIEW reachability_rel_obs_out2 ALTER COLUMN source SET DEFAULT 591;  
\end{sql}



\begin{sql}
INSERT INTO reachability_rel_obs_out2  (flow_id, source, target)
SELECT flow_id, source, target FROM
       (SELECT * FROM
       	       (SELECT 89406 as flow_id,
	       	       switch_id as source,
	       	       483 as target, 
		       (SELECT count(*) FROM
		        pgr_dijkstra('SELECT 1 as id, switch_id as source,
					     next_id as target,
					     1.0::float8 as cost
			              FROM topology', switch_id, 483,FALSE, FALSE)
                       ) AS hops 
                FROM obs_nodes
	       ) AS tmp WHERE hops !=0
       ) AS tmp2 ORDER by hops LIMIT 1;  
\end{sql}
