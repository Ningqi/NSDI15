\section{Verification and synthesis}
\label{sec:veri-syn}

\Subsection{Verification and synthesis as data synchronization}

\todo{(this subsection) HotNet texts, will rework}

A network is in constant change. A virtual view is useful only if its
records are fresh -- reflecting the latest network instantly. For
example, when per-switch rules change, a query on the high-level
policy view \nd{e2e\_routing} (Table~\ref{tb:endpoint}) shall
automatically returns the updated \nd{e2e} reachability. Conversely,
to enable network manipulation via views, the base tables need to be
updated to reflect operations on the views.  For example, to set a new
route \nd{(1,5,4)} for \nd{flow 1} in the example network
(Figure~\ref{fig:eg-one-big-switch} (left)), a user simply insert a new
record denoting the path into the \nd{routing\_policy} view with
\nd{flow} attribute set to \nd{1}. \Sys is responsible of pushing this
abstract view insert into the relevant base \nd{configuration}
inserts.

Generally, view maintenance that keeps virtual views fresh and view
update that synthesizes the base table changes, jointly form a
bi-directional data synchronizer between the base and the view. While
modern DBSes implement view maintenance very efficiently, view update
is supported for restricted
cases~\cite{ak-view-udpate-thesis,relational-lenses}. This is no
surprise, as view update is the harder one: a view contains only partial
information of the base, it is not always possible to locate a unique
base table update~\cite{Bancilhon:view-update-semantics}. To enable
network operations on views, \Sys takes advantage of existing view
maintenance implementation and extends the support of view updates to
network view updates.

\Paragraph{Real-time view maintenance enables network verification.}
\textit{View maintenance} is well supported in modern database systems
(DBS), which \Sys adopts straightforwardly. Specifically, when a view
generated by SQL query program $q$, is queried by a SQL program $p$,
view maintenance translates $p$ on $q$ into queries $p \circ q$ on the
base tables.
% , hence always returning information that is update to the latest
% network state. On the other hand, since views are virtual, This very
% fast re-computation of $p$ keeps the view fresh.  requiring
% re-computation every time it is referred, an alternative is to
% materialize (actually store) the view to accelerate query on the
% views. In this case, view maintenance incrementally updates the
% materialized view table with regard to base table change.
Interestingly, view maintenance offers exactly what is needed in
real-time network verification: by specifying the property of interests
as $p$ over $q$, view maintenance performs check of $p \circ q$ on
network states on the fly. % As shown in \S~\ref{sec:eval},
% checking reachability on a network with more than 10k nodes costs
% less than 10 ms, magnitudes smaller compared to the typically
% per-rule installation or TE operation delay~\cite{b4,ffc}.

\Paragraph{Real-time view update enables network synthesis.}  
Given the ambiguity and non-existence in view update, we first
characterize the correctness criteria in networking. We identify
updates that keep a view's independent and complementary counter-parts
constant. Two views are \textit{independent} if the update on one does
not affect that on the other. Two views are \textit{complementary}, if
they contain enough information to recover the base tables.
% , \ie there alawys exists some base table updates that correctly
% reflect the updated view while keeping the rest views constant.
% In \Sys, it is desirable for views to be independent so they don't
% conflict each other. 
A view updates that keeps the independent views constant eliminates
accident changes made to other existing views; An update that keep a
view's \textit{complementary} constant is a stronger requirement that
does not pollute any possible views (existing and future ones).

\Sys assumes user views are independent, and only performs updates
that keep independent views constant.  In the current prototype, view
update is implemented by hand coded triggers, the call-back functions
that are automatically fired to update the bases when the associated
view update is issued. We evaluate this manual implementation (details
in \S~\ref{sec:eval}) to measure the DB induced delay.
Ultimately, \Sys aims for a generic view update algorithm that
synthesizes for any user-defined views. (We have sketched a novel
algorithm, omitted due to space.) We leave the implementation of the
generic algorithm for future work.

% \input{preliminary-eval}


\subsection{Verification example}

\subsection{Synthesis example}

\begin{sql}
select * from vn_reachability where flow_id = 77899 ;
 flow_id | ingress | egress 
---------+---------+--------
   77899 |     486 |     19  
   ...
\end{sql}

This entry corresponds to a record in configuration as follows:
\begin{sql}
SELECT flow_id, pv FROM configuration_pv WHERE flow_id = 77899;
---------+----------------------------------
 flow_id |                pv                
   77899 | {486,498,462,463,456,472,109,19}
\end{sql}

To update the virtual network policy that revoke transient service for
flow \nd{77899} between ingress \nd{486} and egress \nd{19}, the user
could direcly modify the \nd{vn\_reachability} table by deleting the
corresponding record as follows:
\begin{sql}
DELETE FROM vn_reachability WHERE 
        flow_id = 27079 AND ingress = 486 AND egress = 19;  
\end{sql}

This deletion results in the deletion of three switch-level
configurations as follows:
\begin{sql}
[[77899, 462, 463], [77899, 486, 498], [77899, 498, 462]]  
\end{sql}

\begin{sql}
SELECT flow_id, pv FROM configuration_pv WHERE flow_id = 77899;
 flow_id |                pv                
---------+----------------------------------
   77899 | {483,463,456,472,109,19}
   77899 | {486,498,462,463,456,472,109,19}
   ...
\end{sql}




